0928 수요일
<출석체크>
09:10 문호준, 박근태, 박세웅(지각), 이용수, 정민경(결석), 홍승기(오후)

<공지사항>

<학습목표>
//단축키 ctrl shift o
       해당 클래스외부에서 뭔가 가져다 쓰려면 패키지를 import해줘야되는데 자동import 기능

- 상속, 인터페이스 복습
	상속 : extends 문법으로 코드의 중복을 막기위해서
	     부모클래스에 있는 변수와 메소드를 물려받는 기능
	extends(상속) 와 implements(구현)의 차이
		extends는 '존재' 'be'의 그룹화 목적. 1개의 부모로부터만 상속받을 수 있다.
		implements는 '기능의 강제'의 목적.  여러개의 인터페이스를 구현할 수 있다.
	어떤것을 상속받도록 개발해야할까?  인터페이스의 구현으로 개발해야할까?  
	사람마다 관점의 차이로 개발방법이 달라질수 있다.  
		상위그룹에 공통적인 특성들을 묶어서 하위에서 상속받도록 할건지
		반드시 오버라이딩으로 구현해야할 함수들을 미리 약속해두고 강제할건지
- 제네릭
	<데이터타입> 문법을 통해서 특정자료형을 일반화된 자료형으로 바꾸는 기능
	목적 : 정의시에 결정되던 데이터타입을 인스턴스 생성시 결정되도록 하기위해서
	왜 그렇게 하지?   데이터타입별로 정의해야하는 비효율을 없애주기 때문
	           런타임에 잘못된 타입이 들어올 수 있는것을 컴파일 단계에서 방지
			   타입캐스팅, 타입검사에 들어가는 노력을 줄여준다.
- 컬렉션프레임워크
	> 자바가 미리 만들어놓은 자료구조
	대표적인 3개 : 셋, 맵 리스트       인터페이스.
	- Set : 집합. 구현체로 HashSet이 대표적. 중복을 허락하지 않고, 자료의 순서가 없다.
	        데이터삽입 : 셋.add(값)
	- Map : 키, 밸류 의 쌍.    
	        데이터삽입 : 맵.put(키, 벨류)
	- List : 체인처럼 열거된 자료형.  크기가 고정인 배열의 단점을 보완한 자료구조.
	        구현체로 어레이리스트, 링크드리스트가 대표적.
			데이터삽입 : 리스트.add(값)
	- 큐, 스택 같은 자료구조도 자바가 미리 만들어놨다.
	//스택은 먼저 들어간게 제일 나중에 나온다.
		예) 프링글스, 접시쌓기
	//큐는 반대로 먼저들어간게 제일 먼저 나온다. 
		예) 선착순
- enum
	- Enumeration의 약자. 열거형.
	- 목적 : 우리만의 제한된 데이터타입을 가지기 위해서
	- 정의문법 : enum 이름 { 값, 값, 값}
		예) enum Rainbow {RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET}
	- 호출문법 : 이름.값
		예) Rainbow.RED
	- 모든 Enum은 java.lang.Enum 클래스를 상속받는다. 그래서 그안의 메서드를 사요할수 있다.
	- 메소드 
	   values()  //모든 상수값들을 배열로 반환.       Rainbow[] arr = Rainbow.values();\
	   valueOf()	//상수값 반환.              Rainbow rb = Rainbow.valueOf("GREEN")
	클래스는 변수와 메소드의 집합.   변수만 있는 개념 클래스에 담았어야 했다.
    변수이긴 변수인데 값이 바뀌지않는 상수의 열거타입이다?  enum
	
	 
	
인터페이스에는 함수에대한 약속만 들어갈수있는거 아니다.
	변수를 넣으면 public static final로 선언한것과 같다.
	인터페이스는 반드시 구현해야될 '약속'    값을 변경할수 없으면서 모든 인터페이스의 구현체끼리 공유하는 변수
	해당 인터페이스의 구현체는 반드시 이 동일한 값을 가지고있어야 된다는 제약조건

- 파일 입출력
	CRUD(Create, Read, Update, Delete). 쓰고, 읽고, 수정하고, 지우고
	FileReader, FileWriter, BufferedFileReader
	프로그램이 종료되더라도 데이터를 영구적으로 남기고싶다면?   파일에 저장, DB에 저장.
	- 어떤 폴더의 파일의 이름을 일괄적으로 변경(앞에다가 수정_ 붙이기)  파일.rename 함수
	
	스트링(문자열)
	파일 객체
	인스턴스 생성
	조건문, 반복문
	경로

- 쓰레드(오후)
컴퓨터는 프로세스별로 자원을 할당해요.(운영체제는 프로세스별로 하드웨어의 자원을 할당해요)
프로세스는 자원을 분리해서 쓰지만, 쓰레드는 동일 프로세스내의 자원을 공유해서 쓴다.
단일 프로세스의 단점 : IO작업시 CPU가 놀고있다.
	단점을 극복하기위해 멀티 프로그래밍의 등장.
멀티 프로그래밍 : 목적은 CPU사용의 극대화
	단점 : CPU사용안할때 다른 프로세스가 놀고있음
	해결방안 : 퀀텀이라는 짧은 시간동안 돌려막기
	이것을 멀티태스킹이라고 한다.
멀티 태스킹 : 프로세스의 응답시간을 최소화 시키는 목적 = 마치 여러 프로세스가 동시에 실행되는것처럼 보임.
	단점 : 하나의 프로세스가 동시에 여러작업을 실행하지는 못함.
	//컨텍스트 스위칭, IO 작업은 무거운 작업. 작업의 양이 큰 작업. 
	    프로세스끼리 메모리 공유가 어려움
		하드웨어의 성능을 잘 활용하지 못함(듀얼 코어, 쿼드라 코어 등)
	해결방안 : 쓰레드
쓰레드 : 1개의 프로세스는 최소한 1개의 쓰레드를 가지고있다.  보통은 n개의 멀티쓰레드로 구현되었다.
      CPU의 실행단위.
	 장점 : 컨텍스트 스위칭이 가볍다, 같은 프로세스 내에서는 메모리 공유가 된다.
멀티 쓰레딩 : 하나의 프로세스가 동시에 여러 작업을 실행
	//진짜 멀티쓰레딩이 되려면 하드웨어적으로도 코어가 지원되어야되고, 소프트웨어적으로도 멀티쓰레딩 개발이 되었어야하고
멀티 프로세싱 : 2개이상의 프로세서나 코어를 활용하는 시스템


<자바에서 쓰레드를 구현하는 법>
1. Thread 클래스를 상속
2. Runnable 인터페이스를 구현

<실행>
인스턴스.start();

<대표적인 메소드>
sleep, start, join, run

<쓰레드의 상태>
 (시작, 실행, 정상종료, 비정상종료)


컴퓨터랑 가위바위보를 할거다. 목숨은 5개-> 3명
내턴이되면 5초간의 카운트다운 -> 2명
	5초동안 아무것도 내지못하면 내 턴 종료(그 턴 패배)
	5초안에 내면 카운팅 종료
5승 먼저 한 사람이 승리 -> 1명


- 자바총복습

깨어있지않음 - 사고하지 않음
생각없이 바쁨
조급함
우선 만들고 보자. 구현만 하고보자.
이것만   //다음은 오지않는다.
메모하기 	//필요한 지식 정리
우선순위 정하기
일정관리 : 균형있게 공부하기


게임
재수. 대학생활.
신입1,2년. 2년동안-> 8도착하면 12시까지 롤만.  
	3년차. 특히 최근에 롤을 아예안하고 공부.
	해야되는데... 하니가 공부가 되는데 또 안하면 롤.
	2년동안 20%
	
	2주? 공부가 재밌어지기 시작. 유료강의. 퇴근하면 오늘 뭐배울까.
	6개월 50%
	잘게잘게 업무를 쪼개서 못했는데 할수있게된 작은 성공경험들.
	개발을 목적이 아니라 수단.
	이 기술을 익혀서 궁극적으로 만들고자 하는것, 이루고자 하는것.


리팩토링= 하는 역할은 똑같지만 기존의 코드를 더 나은 코드로 변경하는 작업

메인에서 타이머(쓰레드)의 인스턴스를 만들고 카운팅하는동시에 유저입력 받음
현상 : 유저입력 받은 이후에 실행하는 타이머.start()가 실행이 안되고 Exception이 터진다.
문제 : start가 종료되기 전에 또 start를 호출되었기 때문
	달리기 경기.  시이이이작!!! 뛰고있는데 갑자기 등뒤에서 들리는소리. 또 시이작
해결 : 플래그를 써서 특정조건이 되면 return; 을 해서 타이머의 run이 종료되게끔 만들면된다.

4시간정도의 시간을 줬을때
자바수업을 마친 전공자들도 못한다. 인서울 컴퓨터학부 200명정원에 40명정도 할거고,
	서울대 > 서강대 > 중앙대 > 부산대> 경남대>
	왼쪽으로 갈수록 지금능력이랑 상관없이 주어지면 해낼때까지 계속 도전.
30명정원 국비학원의 1,2명 한다.

